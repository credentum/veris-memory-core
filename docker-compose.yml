# Veris Memory Docker Compose Configuration
#
# DEPLOYMENT STRATEGY:
#   This file has BOTH "image:" (GHCR) and "build:" (local) directives for all services.
#   Docker Compose behavior:
#     - docker compose up         → Pulls from GHCR (fast, 30 sec)
#     - docker compose up --build → Builds locally (slower, 7 min)
#
# AUTOMATIC FALLBACK:
#   If GHCR pull fails (network issue, images not pushed yet), deployment automatically
#   falls back to local build. See scripts/deploy-dev.sh for implementation.
#
# PRODUCTION: Pulls CVE-validated images from GHCR (deployed via GitHub Actions)
# LOCAL DEV: Can build locally or pull from GHCR (developer's choice)

services:
  # Context Store MCP Server (Primary AI Agent Interface)
  context-store:
    image: ghcr.io/credentum/veris-memory-core/context-store:latest
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile
    pull_policy: always
    ports:
      - "8000:8000"  # SECURITY: Accessible via Docker bridge network for MCP clients (external access blocked by firewall)
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - NEO4J_RO_PASSWORD=${NEO4J_RO_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379  # SECURITY: Redis with password auth
      - MCP_SERVER_PORT=8000
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
      - API_KEY_SENTINEL=${SENTINEL_API_KEY}
      - AUTH_REQUIRED=${AUTH_REQUIRED:-true}
      - ENVIRONMENT=${ENVIRONMENT:-development}
      # PR #170: Cache and embedding configuration
      - VERIS_CACHE_TTL_SECONDS=${VERIS_CACHE_TTL_SECONDS:-300}
      - STRICT_EMBEDDINGS=${STRICT_EMBEDDINGS:-false}
      - EMBEDDING_DIM=${EMBEDDING_DIM:-384}  # v1.0 compliance: must be 384
      - QDRANT_COLLECTION_NAME=${QDRANT_COLLECTION_NAME:-context_embeddings}  # Collection name for vector storage
    command: ["python", "-m", "uvicorn", "src.mcp_server.main:app", "--host", "0.0.0.0", "--port", "8000"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - context-store-network

  # REST API Server (Operational Interface & Monitoring)
  api:
    image: ghcr.io/credentum/veris-memory-core/api:latest
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.api
    pull_policy: always
    ports:
      - "127.0.0.1:8001:8001"  # SECURITY: Bind to localhost only
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - NEO4J_RO_PASSWORD=${NEO4J_RO_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379  # SECURITY: Redis with password auth
      - API_SERVER_PORT=8001
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
    command: ["python", "-m", "uvicorn", "src.api.main:app", "--host", "0.0.0.0", "--port", "8001"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/api/v1/health/live"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - context-store-network

  # Vector Database (Qdrant) - Using v1.15.1 with health check tools
  qdrant:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.qdrant
    image: veris-memory/qdrant:v1.15.1-healthcheck
    platform: linux/amd64
    ports:
      - "127.0.0.1:6333:6333"  # SECURITY: Bind to localhost only
      - "127.0.0.1:6334:6334"  # SECURITY: gRPC port - localhost only
    volumes:
      - qdrant_data:/qdrant/storage
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
      - QDRANT__SERVICE__GRPC_PORT=6334
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    networks:
      - context-store-network

  # Graph Database (Neo4j)
  neo4j:
    image: neo4j:5.15-community@sha256:69c579facb7acab1e98f28952b91144c89e469a081804a5dafebd6c3030433b8
    platform: linux/amd64
    ports:
      - "127.0.0.1:7474:7474"  # SECURITY: HTTP - localhost only
      - "127.0.0.1:7687:7687"  # SECURITY: Bolt - localhost only
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
      # Mount initialization scripts for schema setup
      - ./deployments/neo4j-init:/docker-entrypoint-initdb.d:ro
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
      - NEO4J_PLUGINS=["apoc"]
      - NEO4J_dbms_default__listen__address=0.0.0.0
      - NEO4J_dbms_default__advertised__address=localhost
      - NEO4J_dbms_connector_https_advertised__address=localhost:7473
      - NEO4J_dbms_connector_http_advertised__address=localhost:7474
      - NEO4J_dbms_connector_bolt_advertised__address=localhost:7687
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*
      # Enable Neo4j Labs plugins for advanced features
      - NEO4JLABS_PLUGINS=["apoc"]
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:7474",
        ]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    restart: unless-stopped
    networks:
      - context-store-network

  # Cache/KV Store (Redis)
  redis:
    image: redis:7.2.5-alpine@sha256:6aaf3f5e6bc8a592fbfe2cccf19eb36d27c39d12dab4f4b01556b7449e7b1f44
    platform: linux/amd64
    ports:
      - "127.0.0.1:6379:6379"  # SECURITY: Bind to localhost only
    volumes:
      - redis_data:/data
    environment:
      # SECURITY: Use REDISCLI_AUTH to avoid exposing password in process list
      - REDISCLI_AUTH=${REDIS_PASSWORD}
    # SECURITY: Redis with password authentication
    # Password is required via --requirepass flag. If REDIS_PASSWORD is not set,
    # the container will fail to start with an error about missing environment variable.
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --appendonly yes
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --protected-mode yes
    # HEALTHCHECK BEHAVIOR:
    # - If REDIS_PASSWORD is not set: Container fails to start (docker-compose error)
    # - If REDIS_PASSWORD is wrong in healthcheck: Healthcheck fails, container marked unhealthy
    # - If REDIS_PASSWORD is correct: Healthcheck succeeds, container marked healthy
    #
    # SECURITY NOTE: Using REDISCLI_AUTH environment variable instead of -a flag
    # to prevent password exposure in process list (ps aux, docker inspect)
    #
    # Debug failing healthchecks:
    #   docker exec <container> redis-cli ping
    #   docker inspect --format='{{.State.Health.Status}}' <container>
    healthcheck:
      test: ["CMD", "sh", "-c", "redis-cli ping"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped
    networks:
      - context-store-network

  # Monitoring Dashboard Service
  monitoring-dashboard:
    image: ghcr.io/credentum/veris-memory-core/context-store:latest
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile
    pull_policy: always
    ports:
      - "127.0.0.1:8080:8080"  # SECURITY: Bind to localhost only
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379  # SECURITY: Redis with password auth
      - DASHBOARD_PORT=8080
      - MONITORING_ENABLED=true
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
    command: ["python", "-m", "src.monitoring"]
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/dashboard/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 90s
    restart: unless-stopped
    networks:
      - context-store-network

  # Sentinel Monitoring Service - Monitors all S1-S10 checks and sends alerts
  # Requires TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID to be set in GitHub Secrets
  # for Telegram alerting. Get bot token from @BotFather, chat ID from @userinfobot
  sentinel:
    image: ghcr.io/credentum/veris-memory-core/sentinel:latest
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.sentinel
    pull_policy: always
    environment:
      # Telegram Configuration (from GitHub Secrets)
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
      - TELEGRAM_CHAT_ID=${TELEGRAM_CHAT_ID}
      # Sentinel Configuration
      - SENTINEL_CHECK_INTERVAL=60
      - TARGET_BASE_URL=http://context-store:8000  # Changed from SENTINEL_TARGET_URL to match code
      - SENTINEL_API_URL=http://api:8001  # Deprecated, kept for backwards compatibility
      # Service URLs - using consistent naming with other services
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379  # SECURITY: Redis with password auth
      - QDRANT_URL=http://qdrant:6333
      - MONITORING_DASHBOARD_URL=http://monitoring-dashboard:8080
      # API Authentication - Sentinel uses its own dedicated API key
      - SENTINEL_API_KEY=${SENTINEL_API_KEY}
      # General Configuration (required for S7 config parity check)
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      - ENVIRONMENT=${ENVIRONMENT:-production}
    volumes:
      - sentinel_data:/var/lib/sentinel
      # Mount host backup directories for S6 backup validation (read-only)
      # Primary backup location: /backup (RAID1 array /dev/md2)
      # Contains: backup-weekly, backup-monthly, backup-ultimate, daily, monthly,
      #           weekly, restic-repo, health, cleanup, temp
      - /backup:/backup:ro
    ports:
      - "127.0.0.1:9090:9090"  # SECURITY: Bind to localhost only
    depends_on:
      context-store:
        condition: service_healthy
      api:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      redis:
        condition: service_healthy
      monitoring-dashboard:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9090/health"]
      interval: 60s      # Less frequent to reduce load
      timeout: 5s       # Faster timeout
      retries: 5        # More retries for resilience
      start_period: 120s # Longer startup grace period
    restart: unless-stopped
    networks:
      - context-store-network

volumes:
  # IMPORTANT: Using external volumes with explicit names to preserve data across deployments
  # This ensures that data persists even when using different project names (-p flag)
  # These volumes match the original veris-memory_* names to preserve existing data
  qdrant_data:
    external: true
    name: veris-memory-core_qdrant_data
  neo4j_data:
    external: true
    name: veris-memory-core_neo4j_data
  neo4j_logs:
    external: true
    name: veris-memory-core_neo4j_logs
  redis_data:
    external: true
    name: veris-memory-core_redis_data
  sentinel_data:
    external: true
    name: veris-memory-core_sentinel_data

networks:
  context-store-network:
    driver: bridge
    name: veris-memory-core_context-store-network
